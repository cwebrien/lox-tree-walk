package com.lox.tool;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class AstGenerator {

    private static final String TAB = "   ";

    /**
     * Generates Java class source for abstract syntax trees into the specified output directory.
     * @param args A single argument, the output directory for the .java source files
     * @throws IOException If we cannot successfully write the files
     */
    public static void main(String[] args) throws IOException {
        if (args.length != 1) {
            System.err.println("Usage: generate_ast <output_directory>");
            System.exit(64);
        }

        System.out.println("Generating AST");
        String outputDir = args[0];
        generateAstClass(outputDir, "Expression");
    }

    /**
     * Generates the AST parent class
     * @param outputDir Where to write the .java file
     * @param baseName The name for the AST parent class
     * @throws IOException If writing fails
     */
    public static void generateAstClass(String outputDir, String baseName) throws IOException {
        String path = outputDir + "/" + baseName + ".java";
        PrintWriter writer = new PrintWriter(path, "UTF-8");

        Map<String, List<String>> astClassToFields = Map.ofEntries(
                Map.entry("Binary", Arrays.asList("Expression left", "Token token", "Expression right")),
                Map.entry("Grouping", Arrays.asList("Expression expression")),
                Map.entry("Literal", Arrays.asList("Object value")),
                Map.entry("Unary", Arrays.asList("Token operator", "Expression right"))
        );

        writer.println("package com.lox;");
        writer.println();

        writer.println("/* This class is generated by com.lox.tool.AstGenerator */");
        writer.println();

        writer.println("import java.util.List;");
        writer.println();

        writer.println("abstract class " + baseName + " {");

        generateVisitorInterface(writer, astClassToFields.keySet());
        writer.println();

        writer.println(TAB + "abstract <R> R accept(Visitor<R> visitor);");
        writer.println();

        astClassToFields.forEach((type, fieldList) -> {
            generateNestedAstSubClass(writer, baseName, type, fieldList);
            writer.println();
        });

        writer.println("}");

        writer.close();
    }

    /**
     * The AST has a number of sub-classes which define different types of syntax nodes. This method writes a single
     * instance of a sub-class.
     * @param writer To pump out the source code
     * @param baseName Name of the parent class
     * @param subclassName Name of the sub-class to create
     * @param fieldList Fields for this sub-class. These are of the former "DataType fieldName", e.g. "Expression left"
     */
    public static void generateNestedAstSubClass(PrintWriter writer, String baseName, String subclassName, List<String> fieldList) {

        // Set up class with constructor and member field initialization
        writer.println(TAB + "static class " + subclassName + " extends " + baseName + " {");

        fieldList.forEach(field -> writer.println(TAB + TAB + "final " + field + ";"));
        writer.println();

        String constructorArguments = String.join(", ", fieldList);
        writer.println(TAB + TAB + subclassName + "(" + constructorArguments + ") {");

        fieldList.forEach(field -> {
            String fieldName = field.split(" ")[1];
            writer.println(TAB + TAB + TAB + "this." + fieldName + " = " + fieldName + ";");
        });

        writer.println(TAB + TAB + "}");
        writer.println();

        // Override accept() method
        writer.println(TAB + TAB + "@Override");
        writer.println(TAB + TAB + "<R> R accept(Visitor<R> visitor) {");
        writer.println(TAB + TAB + TAB + "return visitor.visit" + subclassName + "(this);");
        writer.println(TAB + TAB + "}");

        writer.println(TAB + "}");
    }

    /**
     * Writes the visitor interface requisite for the interpreter to interact with the AST and its nodes.
     * @param writer To pump out the source code
     * @param subclassList Sub-classes in scope for visiting
     */
    public static void generateVisitorInterface(PrintWriter writer, Set<String> subclassList) {
        writer.println(TAB + "interface Visitor<R> {");

        subclassList.forEach(subclassName -> writer.println(TAB + TAB + "R visit" + subclassName + "(" + subclassName + " " + subclassName.toLowerCase() + ");"));

        writer.println(TAB + "}");
    }

}
